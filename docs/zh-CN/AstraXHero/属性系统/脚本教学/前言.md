---
title: 前言
description: AstraXHero 前言
---
# 前言
## 属性注册
::: info
本插件不提供任何内置属性，如果要注册一个属性，你需要在 `script/attribute`内新建一个以.js结尾的文件(javascript文件)
:::
```js
const id = "属性id"
const placeholder = "placeholder占位符"
const display = "测试属性"  
const combat_value = 10.0  
const priority = 96  
const type = "EXTRA"
```
这样你就注册好了一个名为 `测试属性`、战斗力为`10.0`(目前只是设置，后续版本考虑增加战斗力)、优先级为`96`、属性类型为`EXTRA` 的属性
## 脚本加载
::: tip
本插件拥有一套 JavaScript 加载系统，该系统能让你加载 plugins/ 目录下任意位置的JavaScript脚本，但我永远推荐你将你的额外脚本存放在本插件配置目录中 script/basic/ 目录下。
:::
AstraXHero/script/basic/fight.js
```js
Plus = Tool.operation("plus") // 加

/* 公式定义 */
const ATK = {
    common: "{a.axh_attr:ATK_random} - {d.axh_attr:DEF_random}",
}

/**
 * @description 计算表达式
 * @param {*} data 数据
 * @param {string} expression 表达式
 * @returns {double} 计算结果
 */
function calc(data, expression) {
    return eval(data.handleStr(expression, true))
}

/**
 * 添加某来源的伤害
 * @param {*} data 战斗数据
 * @param {string} source 伤害来源
 * @param {double} value 值
 */
function plus(data, source, value) {
    data.damageSources.put(source, Plus.element(value))
}
```
假如现有一个 fight.js 脚本文件，并存放在了 AstraXHero/script/basic/ 目录下。现在你想使用该脚本封装好的函数或变量，你应该在使用该 fight.js 的脚本属性的最上方使用load("plugins/AstraXHero/script/basic/fight.js") 如下所示:
```js {1,11}
load("plugins/AstraXHero/script/basic/fight.js")

const id = "ATK"
const placeholder = "ATK"
const display = "攻击属性"
const combat_value = 5.0
const priority = 2
const type = "ATTACK"
  
function onAttack(data) {
	// 使用 fight.js 中的 calc 函数，解析 fight.js 中的 ATK.common 公式常量
	let damage = calc(data, ATK.common)
	if(damage > 0) {
		// 向伤害表中增加一个伤害为 damage 的 “示例”伤害源
		plus(data, "示例", damage)
	}
	// 返回出去的值，会以属性id作为 key 返回值作为 value 存储在 data中
	return damage
}
```
:::danger 警告
如果需要使用外部来源的脚本，请务必在使用前先使用 load 加载；如果同时load了两个外部来源的脚本，请确保它们没有相同函数名、变量名等，否则过不了编译
:::
## 战斗数据
你会发现，在所有脚本属性触发器中，有且仅有一个参数data，data就是我们的战斗数据，顾名思义，就是战斗过程中产生的数据，它本质上是一个哈希表结构，通过 key:value 的形式将战斗变量存储在其内部。
如果在脚本触发器中想要使用data中战斗产生变量，请使用 data[key] 来获取变量，如果不知道有什么战斗变量能使用，请打开Debug模式，攻击一下实体，就能在后台看到调试信息。接下来我为大家贴出data常用的内部变量(注意，非战斗产生的变量，下面贴出来的是能通过 data.xxx 直接使用的)
```kotlin
/* 战斗缓存 */
var cache = DataCache(this)

/* 攻击者 默认仅在 ATTACK、DEFENSE 存在*/
var attacker: LivingEntity

/* 防御者 默认仅在 ATTACK、DEFENSE 存在*/
var defender: LivingEntity

/* 自身 默认仅在 UPDATE、RUNTIME 存在*/
var self: LivingEntity

/* 攻击者的属性数据集 */
val attackerData: AttributeDataCompound

/* 防御者的属性数据集 */
val defenderData: AttributeDataCompound

/* 自身的属性数据集 */
val selfData: AttributeDataCompound

/* 当前战斗数据的event */
var event: Cancellable

/* 伤害来源表 */
val damageSources = LinkedHashMap<String, OperationElement>()

/**
* 解析字符串中的 papi
* {a.player_health} 表示解析 attacker 的 player_health 变量
* {d.player_health} 表示解析 defender 的 player_health 变量
*
* @param string 待解析字符串
* @return 解析后的字符串
*/
fun handleStr(string: String, log: Boolean = true): String
```